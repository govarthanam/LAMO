#include "/home/pi/opencv-3.0.0/core.hpp"
#include "/home/pi/opencv-3.0.0/cv.h"
#include "crop.h"
#include "preprocess.h"
#include "find_laser.h"
#include <stdio.h>
#include <unistd.h>			//Used for UART
#include <fcntl.h>			//Used for UART
#include <termios.h>			//used for UART
#include<stdint.h>
#include <stdlib.h>
int uart0_filestream = -1;
#define N 3
using namespace std;
using namespace cv;
int weight_sum,X,Y;
int val_x[N] , val_y[N] , iter , weight[N];

/*####################################################*/ 
void send_data_uart(int x, int y)
{
        double uart_time = static_cast<double>(cv::getTickCount());
   	uint16_t x1, y1;
      	x1=(uint16_t)x;
	y1=(uint16_t)y;
	unsigned char tx_buffer[10] = { 0x55, 0x21, 0xcc, 0x06, 0x44, 0, 0, 0, 0, 0x42 };	
	// set positions to char array
	tx_buffer[5] = (char)(x1%256);				//  X_LSB
	tx_buffer[6] = (char)((x1 & 0xff00)>>8 );		//  X_MSB		
	tx_buffer[7] = (char)(y1&0xff);				//  Y_LSB
	tx_buffer[8] = (char)((y1 & 0xff00)  >>8);		//  Y_MSB

	if (uart0_filestream != -1)
	{
		int count = write(uart0_filestream, &tx_buffer[0], 10);
		//printf("%d bytes written",count);
		if (count < 0)
		{
			printf("UART TX error\n");
		}
	}
        uart_time= static_cast<double>(cv::getTickCount()) - uart_time;
	uart_time /= cv::getTickFrequency();
	std::cout<<"uart_time = "<<uart_time<<"\n";
}

/*####################################################*/
class WeightedAverage
{
	private :
		//  define N for moving average filter
		#define N 3
		//  declare array for checking average filter
		int val_x[N] , val_y[N] , iter , weight[N];
		//  to find position and to store sum of weights
		int weight_sum,X,Y;
	public :
		WeightedAverage()		// constructor
		{
			// initialize weighted array
			weight[0] = 1;
			weight[1] = 3;
			weight[2] = 5;
			weight[3] = 8;
			//  set all values of array to ZERO
			for( int aa =0; aa<N; aa++)
			{
				val_x[aa] = 0;
				val_y[aa] = 0;
			}
			//  initailize weight_sum as zero
			weight_sum = 0;
			// iter value is initially 0
			iter = X = Y =0;
			//  find the sum of the weighted array
			for( int ws=0; ws<N; ws++)
				weight_sum += weight[ws];			
		}
		//  create function to find weighted average
		void FindWeightAvg ( int &,int &);
		//create a vector of points
		vector<cv::Point2i> pts;
};

/*####################################################*/
class WarpImage
{
	private :
		//  temp variables to find quadrants
		float minval,val,temp1,temp2;
		//  declare quadrants to store the quadrants
		cv::Point2i quad1,quad2,quad3,quad4;
		cv::Point2i new_quad1,new_quad2,new_quad3,new_quad4;
		//  floating points array to store the two set of four quadrants
		cv::Point2f pts1[4],pts2[4];
		//  variables used to resize calibration image
		int MTRX,SCALE,flag;
		//  matrix used for applying perspective transfrom
 		cv::Mat lambda,output;
	public :
		// constructor
		WarpImage()
		{
			minval = val  = temp1 = temp2 = 0.0;
			SCALE = MTRX = flag = 0;
		}
		//  function to find corners(quadrants) and save it and to get perspective matrix
		void GetCorners(cv::Mat );
		//  function to warp the image
		cv::Mat ApplyPersp(cv::Mat &);
};


/*####################################################*/
void WeightedAverage::FindWeightAvg( int &x, int&y)
{	
	double weightedaverage_time = static_cast<double>(cv::getTickCount());
	//write the position to vector of points
	pts.push_back(cv::Point2i(x,y));
	//double dura = cv::getTickCount();
	//std::cout<<((cv::getTickCount() - dura) / cv::getTickFrequency());
	//  assign the position to copy, to find average
	X = x;
	Y = y;
	/***************************************************************************************
	find the average location of laser pointer by weighted average
	***************************************************************************************/
	//   before sending the position apply maximum averaging filter
	if( iter < N )
	{
		val_x[ iter] = x;
		val_y[ iter] = Y;
		//  display the (x,y)
	//std::cout<<"   average x = "<<x<<",y = "<<Y<<"\n";
	}
	else
	{
		//  shift the location of array
		for (int cc = 0 ; cc< N-1 ; cc++)
		{
			val_x[cc] = val_x[cc+1];
			val_y[cc] = val_y[cc+1];
		}
		//  add new to location as the last element
		val_x[N-1] = X;
		val_y[N-1] = Y;
		//  decrement the iter to maintain in value of N
		--iter;
	}
	//  increment the iteration
	++iter; 

	//  check whether iter is > 4 and find average
	if( iter == N)
	{
		 X=0; Y=0;
		//  find average of the position
		for ( int t=0 ; t < N ; t++)
		{
			X += ( val_x[t] * weight[t] );
			Y += ( val_y[t] * weight[t] );
		}
		X /= weight_sum;
		Y /= weight_sum;
		//  display the (X,Y)
	//std::cout<<"   average X = "<<X<<",Y = "<<Y<<"\n\n";
	}
	//  if the position before finding weighted avg is (0,0) then set iter a 'zero'
	if( x==0 && y==0)
		iter = 0;
	//  Since, (x,y) are referenced, assign weighted avg (X,Y) to (x,y)
	x = X;	y = Y;
 	weightedaverage_time= static_cast<double>(cv::getTickCount()) - weightedaverage_time;
	weightedaverage_time /= cv::getTickFrequency();
	std::cout<<"weightedaverage_time = "<<weightedaverage_time<<"\n";
}


/*####################################################*/
void WarpImage::GetCorners(Mat image_dup)
{  
	double getcorners_time = static_cast<double>(cv::getTickCount());
	//  create a new matrix to store resized image
	Mat image;
	//  set SCALE and MTRX
	SCALE = 4;
	MTRX = 50;
	//  resize the image to SCALEd size
	resize(image_dup, image, Size(image_dup.cols/SCALE,image_dup.rows/SCALE), 0, 0, 1);
	// finding corners (quadrant1) in top left quadrant
	do
	{
		int MTRX_CPY = MTRX; flag=0;
		for(int i=0; i<MTRX_CPY; i++)
		{
			for(int j=0; j<MTRX_CPY; j++)
			{
				if(image.at<uchar>(i,j) == 0)
					continue;
				else
				{
					temp1 = (float) i*i; temp2 = (float) j*j;
					val = sqrt(temp1+temp2);
					if( flag == 0 )
					{
						minval = val;
						quad1 = cv::Point(j,i);
						flag = 1;
					}
					else
					if( val < minval )
					{
						minval = val;
						quad1 = cv::Point(j,i);					
					}
				}
			}	//  end of for loop
		}		// end of outer for loop
		MTRX_CPY *= 2;									//  if no quadrant (border) found, increment MTRX value and try again
		if( MTRX_CPY > image.cols*image.rows/4) 
			break;
	}while(flag==0);	// end of while
	// finding corners (quadrant2) in top right quadrant
	do
	{ 
		int MTRX_CPY = MTRX; flag=0;
		for(int i=image.cols-MTRX,i1=0; i1<MTRX; i1++,i++)
		{
			for(int j=0; j<MTRX; j++)
			{
				if(image.at<uchar>(j,i) == 0)
					continue;
				else
				{
					temp1 = (float) ((i-image.cols)*(i-image.cols)); temp2 = (float) j*j;
					val = sqrt(temp1+temp2);
 					if( flag == 0 )
					{
						minval = val;
						quad2 = cv::Point(i,j);
						flag = 1;
					}
					else
					 if( val < minval )
					 {
						minval = val;
						quad2 = cv::Point(i,j);						
					 }
				}	
			}	//  end of for loop
		}	//  end of outer  for loop
		MTRX_CPY *= 2;							//  if no quadrant (border) found, increment MTRX value and try again
		if( MTRX_CPY > image.cols*image.rows/4) 
			break;
	}while(flag==0); // end of while
	// finding corners (quadrant3) in bottom left quadrant	
	do
	{
		int MTRX_CPY = MTRX; flag=0;
		for(int i=0; i<MTRX; i++)
		{
			for(int j=0+image.rows-MTRX,j1=0; j1<MTRX; j++,j1++)
			{
				if(image.at<uchar>(j,i) == 0)
					continue;
				else
				{
					temp1 = (float) i*i; temp2 = (float) (j-image.rows)*(j-image.rows);
					val = sqrt(temp1+temp2);
 					if( flag == 0 )
					{
						minval = val;
						quad3 = cv::Point(i,j);
						flag = 1;
					}
					else
					 if( val < minval )
					 {
						minval = val;
						quad3 = cv::Point(i,j);						
					 }
				}
			}	//  end of for loop
		}	//  end of outer for loop
		MTRX_CPY *= 2;							//  if no quadrant (border) found, increment MTRX value and try again
		if( MTRX_CPY > image.cols*image.rows/4) 
			break;
	}while(flag==0); // end of while
	// finding corners (quadrant4) in bottom right quadrant
	do
	{
		int MTRX_CPY = MTRX; flag=0;
		for(int i=image.cols-MTRX,i1=0; i1<MTRX; i1++,i++)
		{
			for(int j=0+image.rows-MTRX,j1=0; j1<MTRX; j++,j1++)
			{
				if(image.at<uchar>(j,i) == 0)
					continue;
				else
				{
					temp1 = (float) ((i-image.cols)*(i-image.cols));  temp2 = (float) (j-image.rows)*(j-image.rows);
					val = sqrt(temp1+temp2);
 					if( flag == 0 )
					{
						minval = val;
						quad4 = cv::Point(i,j);
						flag =1;
					}
					else
					 if( val < minval )
					 {
						minval = val;
						quad4 = cv::Point(i,j);						
					 }
				}
			}	//  end of for loop
		}	//  end of outer for loop
		MTRX_CPY *= 2; //  if no quadrant (border) found, increment MTRX value and try again
		if( MTRX_CPY > image.cols*image.rows/4) 
			break;
	}while(flag==0); // end of while
	//  rescale  co-ordinates to orginal size of image
	quad1 *= SCALE;  quad2 *= SCALE;  quad3 *= SCALE; quad4 *= SCALE;
	//  set new quadrants {borders} to warp image
	new_quad1 = Point(0,0); 
	new_quad2 = Point(image_dup.cols-1,0);
	new_quad3 = Point(0,image_dup.rows-1);
	new_quad4 = Point(image_dup.cols-1,image_dup.rows-1);
	// define two floating point arrays to get perspective matrix
	//  first array holds the quadrants (cornes) of original image
	pts1[0] = Point2f(quad1); 
	pts1[1] = Point2f(quad2); 
	pts1[2] = Point2f(quad3); 
	pts1[3] = Point2f(quad4);
	//  second array holds the quadrants (borders) in warped images
	pts2[0] = Point2f(new_quad1);
	pts2[1] = Point2f(new_quad2);
	pts2[2] = Point2f(new_quad3);
	pts2[3] = Point2f(new_quad4);
	//  store the perspective matrix in lambda			
	lambda  = cv::getPerspectiveTransform(pts1,pts2);
	// set size and type for output matrix to store warped image
	output = cv::Mat(image_dup.size(),image_dup.type());
 	getcorners_time= static_cast<double>(cv::getTickCount()) - getcorners_time;
	getcorners_time /= cv::getTickFrequency();
	std::cout<<"getcorners_time = "<<getcorners_time<<"\n";
}
cv::Mat WarpImage::ApplyPersp(Mat &to_b_warped)
{	double persp_time = static_cast<double>(cv::getTickCount());	
	/////////////////////////////////////////////////////////////////////////////////
	//  perspective transformation to warp the image
	//  convert to float
	//printf("Entered applypers");	
	to_b_warped.convertTo(to_b_warped,CV_32FC1,1.0/255.0);	
	//  warp the image using inbuilt function
	cv::warpPerspective(to_b_warped,output,lambda,to_b_warped.size());
	//  convert the float matrix to original form
	output.convertTo(output,CV_8UC1,255);
	/////////////////////////////////////////////////////////////////////////////////
	persp_time= static_cast<double>(cv::getTickCount()) - persp_time;
	persp_time /= cv::getTickFrequency();
	std::cout<<"persp_time = "<<persp_time<<"\n";
	return output;
}


/*####################################################*/
cv::Mat PreprocessImage::Preprocess(cv::Mat &src)	
{	
	double preprocess_time = static_cast<double>(cv::getTickCount());
	// declare a destination matrix
	cv::Mat dest;
	//  convert to float matrix
	src.convertTo(dest,CV_32FC1,1.0/255.0);		
	//  apply power transformation (GAMMA corection )	
	cv::pow(dest,VAL,dest);
	//  convert from float to original form
	dest.convertTo(src,CV_8UC1,255);
	// apply gaussian blur in GAMMA corrected image
	cv::GaussianBlur(src,src,cv::Size(3,3),1.0,0.0);
	//  return the pre-processed image
	preprocess_time= static_cast<double>(cv::getTickCount()) - preprocess_time;
	preprocess_time /= cv::getTickFrequency();
	std::cout<<"preprocess_time = "<<preprocess_time<<"\n";
	return src;
}


/*####################################################*/
void FindLaser::check_laser(cv::Mat &red, int &x, int &y)
{	

	double laser_find_time = static_cast<double>(cv::getTickCount());	
	//printf("laser start");	
	//  consider initially that laser is not detected
	laser_found = 0;
	//  set limit for rect_x and rect_y
	RECT_H = red.rows/20; RECT_W = red.cols/20;
	//std::cout<<"width = "<<red.cols<<" height = "<<red.rows<<"\n";
	//std::cout<<"rect_h = "<<RECT_H<<" rect_w = "<<RECT_W<<"\n";
	//  set MAX and MIN LIMITs
	MAX_LIMIT = (int)((1/5.0) * RECT_H * RECT_W );
	MIN_LIMIT = (MAX_LIMIT/ 25);
	//std::cout<<MAX_LIMIT<<","<<MIN_LIMIT<<"\n";
	/************************************************************************************************************
	find contours by setting threshold value as 20
	*************************************************************************************************************/
	//  find maximum point location
	cv::minMaxLoc(red,0,&maxval,0,&maxloc);
	//  convert to binary by applying threshold
	cv::threshold(red,binary,(int)maxval-THRESH,255,cv::THRESH_BINARY);
	//  find contours in binary image
	findContours( binary, contours, hierarchy,CV_RETR_TREE,CV_CHAIN_APPROX_SIMPLE); 
	//  set contour size to no_of_contours
	no_of_contours = contours.size();
	//std::cout<<"No_Contour ="<<no_of_contours<<"\n";
	/**************************************************************************************************************
	algorithm to find laser pointer
	**************************************************************************************************************/
	if(no_of_contours == 1 )
	{
		//  check whether the contour if it matches the size of laser spot
		//std::cout<<"area = "<<contourArea(contours[0],0)<<"\n";
		//std::cout<<"Max = "<<MAX_LIMIT<<"\n"<<"Min = "<<(MIN_LIMIT-5)<<"\n";

		if( contourArea(contours[0],0) <= MAX_LIMIT && contourArea(contours[0],0) >= MIN_LIMIT )
		{
			  
			new_rect = boundingRect(contours[0]);							//  Find the bounding rectangle this contour
			laser_found = 1;	//  set flag as true
		}
	}
	else
	{ 
		//  check for all contours if any contour matches the size of laser spot
		for(unsigned int tem = 0; tem< contours.size(); tem++ )
		{
			//  assign the size of contour to 'temp'
			double temp=contourArea( contours[tem],false ); 
			   // std::cout<<"area["<<tem<<"] = "<<temp<<"\n";
			//  check whether the area id=s in betwen the limit
			if( temp <= MAX_LIMIT && temp >= MIN_LIMIT )
			{
				    //std::cout<<"passed->area["<<tem<<"] = "<<temp<<"\n";
				new_rect = boundingRect(contours[tem]);						//  Find the bounding rectangle this contour
				//  check the size of contour is similar to the size of laser spot
				if( new_rect.width < RECT_W && new_rect.height < RECT_H )
				{
					laser_found = 1 ;		//  set flag as true
					break; 
				}				
			}
		}	//  end of for loop
	}	//end of if
	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//  crop the detected contour from the source image
	red_small = red(new_rect).clone();
	//  find maximum point location in the contour
	cv::minMaxLoc(red,0,&maxval,0,&maxloc);
	//  if the maxval is les then 'laser_threshold' value, set laser is not detected
	if( maxval < laser_thresh )
	{
		laser_found = 0;
	}
		//std::cout<<"maxval = "<<maxval<<"\n";

	/******************************************************************************
	new
	******************************************************************************/
	if(laser_found == 0 )
	{
	// convert to binary by applying threshold
	cv::threshold(red,binary,245,255,cv::THRESH_BINARY);
	//  extract contours in binary image
	findContours( binary, contours, hierarchy,CV_RETR_TREE,CV_CHAIN_APPROX_SIMPLE);
	//  set laser found if we have a single contour in laser intensity value
	//  size of contour should be lesser then the MAX_LIMIT, but MIN_LIMIT is not needed to be checked
	if( contours.size() == 1 && contourArea(contours[0],0) <= MAX_LIMIT )
		laser_found = 1;
	}
	/******************************************************************************
	new
	******************************************************************************/

	// if laser found, reduce the x and y  values to fit RED image from extended
	/**************************************************************************************************************
	algorithm to find laser pointer
	**************************************************************************************************************/
	if( laser_found == 1)
	{
		POS_X = maxloc.x;
		POS_Y = maxloc.y;
			//std::cout<<"x = "<<POS_X<<"\ty = "<<POS_Y<<"\n";
			//std::cout<<"maxval = "<<maxval<<"\n";
		// convert the x and y positions to range of XYResolution from range of red.rows,red.cols
		POS_X = (int) ( 0.5 + (float)POS_X/red.cols * XYRESOLUTION);
		POS_Y = (int) ( 0.5 + (float)POS_Y/red.rows * XYRESOLUTION);
		//  write the x and y positions to console
		// std::cout<<"x = "<<POS_X<<"\ty = "<<POS_Y<<"\n";
		//    cv::line(red,cv::Point(0,0),cv::Point(maxloc.x,maxloc.y),255,1);
	}	
	else
	{
		POS_X = 0;
		POS_Y = 0;
	}	
	//  set position of laser pointer to (x,y)
	x = POS_X;
	y = POS_Y;
	std::cout<<"x="<<x<<" "<<"y="<<y<<endl;	//  show red image
	send_data_uart(x,y);
	laser_find_time= static_cast<double>(cv::getTickCount()) - laser_find_time;
	laser_find_time /= cv::getTickFrequency();
	std::cout<<"laser_find_time = "<<laser_find_time<<"\n";
}//  end of class FindLaser


/*################################################################*/
WarpImage object;
Mat CropImage::CropCalibImage( Mat &src,Mat &cropd,Mat &red)
{		
	
	double crop_time = static_cast<double>(cv::getTickCount());
	//  split planes to B G R
	split(src,planes);
	//  store red plane in gray
	gray  = planes[2];
	//  threshold the gray image
	threshold(gray,gray,THR_CROP,255,THRESH_BINARY); 
	//  make green as copy of gray 
	red = gray.clone();
	//******************************************************************************************************
	//  Find the contours in the image
	findContours( gray, contours, hierarchy,CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE ); 
	//  Find the biggest contour in the image (Screen)
	for(unsigned int i = 0; i< contours.size(); i++ )
	{
		double temp=contourArea( contours[i],false ); 
		if( temp > (double)largest_area )
		{
			largest_area = (int)temp;
			largest_contour_index = i;                 //  Store the index of largest contour
			bounding_rect = boundingRect(contours[i]); //  Find the bounding rectangle(borders) of biggest contour
		 }	//  end of if
	}	//  end of for loop
	//*****************************************************************************************************
	//  crop the projkection screen from entire image
	cropd = red(bounding_rect).clone();
	////////////////////////////////////////////////////////////
	//  apply algorithm to find corners in the cropped image
	object.GetCorners(cropd);
	///////////////////////////////////////////////////////////
	//  return the cropped image
	crop_time= static_cast<double>(cv::getTickCount()) - crop_time;
	crop_time /= cv::getTickFrequency();
	std::cout<<"crop_time = "<<crop_time<<"\n";
	return cropd;
 }

/*####################################################*/
Mat CropImage::ApplyWarp( cv::Mat &src,Mat &red, Mat &cropd )
{
	double warp_time = static_cast<double>(cv::getTickCount());	
	split(src,planes);
	red = planes[1];
	cropd = red(bounding_rect).clone();
	cropd = object.ApplyPersp(cropd);
	//  return the warped image
	warp_time= static_cast<double>(cv::getTickCount()) - warp_time;
	warp_time /= cv::getTickFrequency();
	std::cout<<"warp_time = "<<warp_time<<"\n";
	return cropd;
}

VideoCapture cap(0);

void cam_set_laser()
{
	int ret;
	ret = system("uvcdynctrl -s 'Brightness' 62");
	if(ret == -1)
	cout<<"Brightness is not set.\n";
        ret = system("uvcdynctrl -s 'Contrast' 106");
        if(ret == -1)
        cout<<"Contrast is not set.\n";
        ret = system("uvcdynctrl -s 'Gain (Absolute)' 60");
        if(ret == -1)
        cout<<"Gain is not set.\n";
        ret = system("uvcdynctrl -s 'Saturation' 26");
        if(ret == -1)
        cout<<"Saturation is not set.\n";
	//ret = system("uvcdynctrl -s 'Exposure, Auto' 1");
	ret = system("uvcdynctrl -s 'Exposure (Absolute)' 9");
	if(ret == -1)
        cout<<"Exposure is not set.\n";	
	//ret = system("uvcdynctrl -g 'Exposure (Absolute)'");
        //cout<<ret;
        ret = system("uvcdynctrl -s 'Focus, Auto' 0");
	ret = system("uvcdynctrl -s 'Focus (Absolute)' 14");
        if(ret == -1)
        cout<<"Focus is not set.\n";
	ret = system("uvcdynctrl -s 'White Balance Temperature, Auto' 0");
	ret = system("uvcdynctrl -s 'White Balance Temperature' 4500");
        //duration = static_cast<double>(cv::getTickCount()) - duration;
	//duration /= cv::getTickFrequency();
	//std::cout<<"cam setting time = "<<duration<<"\n";
	
} 
void cam_set_red()
{
	
	//duration = static_cast<double>(cv::getTickCount());
	int ret;
	ret = system("uvcdynctrl -s 'Brightness' 62");
	if(ret == -1)
	cout<<"Brightness is not set.\n";
        ret = system("uvcdynctrl -s 'Contrast' 106");
        if(ret == -1)
        cout<<"Contrast is not set.\n";
        ret = system("uvcdynctrl -s 'Gain (Absolute)' 60");
        if(ret == -1)
        cout<<"Gain is not set.\n";
        ret = system("uvcdynctrl -s 'Saturation' 26");
        if(ret == -1)
        cout<<"Saturation is not set.\n";
	//ret = system("uvcdynctrl -s 'Exposure, Auto' 1");
	ret = system("uvcdynctrl -s 'Exposure (Absolute)' 9");
	if(ret == -1)
        cout<<"Exposure is not set.\n";	
	//ret = system("uvcdynctrl -g 'Exposure (Absolute)'");
        //cout<<ret;
        ret = system("uvcdynctrl -s 'Focus, Auto' 0");
	ret = system("uvcdynctrl -s 'Focus (Absolute)' 14");
        if(ret == -1)
        cout<<"Focus is not set.\n";
	ret = system("uvcdynctrl -s 'White Balance Temperature, Auto' 0");
	ret = system("uvcdynctrl -s 'White Balance Temperature' 4500");
	
} 

/*#############################################*/
int  main()
{
        double sourc_time=0; 
	cap.set(CV_CAP_PROP_FRAME_WIDTH, 1920);
	cap.set(CV_CAP_PROP_FRAME_HEIGHT, 1080);
	cap.set(CV_CAP_PROP_FPS,2);
	if(!cap.isOpened())
	return -1;
  
 	//cam_set_red();

	/*#############################################*/
	
	uart0_filestream = open("/dev/ttyAMA0", O_RDWR | O_NOCTTY | O_NDELAY);		//Open in non blocking read/write mode
	if (uart0_filestream == -1)
	 {
		//ERROR - CAN'T OPEN SERIAL PORT
		printf("Error - Unable to open UART.  Ensure it is not in use by another application\n");
	 }
	//CONFIGURING THE UART
	struct termios options;
	tcgetattr(uart0_filestream, &options);
	options.c_cflag = B9600 | CS8 | CLOCAL | CREAD;		//<Set baud rate
	options.c_iflag = IGNPAR;
	options.c_oflag = 0;
	options.c_lflag = 0;
	tcflush(uart0_filestream, TCIFLUSH);
	tcsetattr(uart0_filestream, TCSANOW, &options);
	
	/*#############################################*/

	
	//creating objects to access different files
	CropImage crop_var;
	FindLaser laser_var;
	PreprocessImage pow_var;
	char nam[75];
	//  declare matricies
	cv::Mat src_calib,cropd_calib,red_calib,red,cropd, src;
	//  declare variables for x,y positions
	int X = 0, Y = 0;
	//  read image	
	src_calib = cv::imread("red.jpg");
	if(src_calib.empty())
	 {
		std::cout<<"error in reading file";
		getchar();
		return -2;
	 }
	//crop the caliber image
	cropd_calib = crop_var.CropImage::CropCalibImage(src_calib,cropd_calib,red_calib); 
	char key;
	//cam_set_laser();

	do
	 {

	  //getting the first duration
	  double duration = static_cast<double>(cv::getTickCount());
	  sourc_time = static_cast<double>(cv::getTickCount());
	  cap >> src;
	  sourc_time= static_cast<double>(cv::getTickCount()) - sourc_time;
	  sourc_time /= cv::getTickFrequency();
	  std::cout<<"sourc_time = "<<sourc_time<<"\n";
	
	  if(src.empty())
	  {
		std::cout<<"error in reading laser file";
		getchar();
		continue;
	  }	
	  //crop new image
	  cropd  = crop_var.ApplyWarp(src,red,cropd);
	  //create a dest matrix
	  cv::Mat power;	
	  //call power transformation(gamma) function
	  power = pow_var.Preprocess(cropd);
	  //find the location of the laser	  
	  laser_var.check_laser(power,X,Y);		
	  duration = static_cast<double>(cv::getTickCount()) - duration;
	  duration /= cv::getTickFrequency();
	  std::cout<<"total Processing time = "<<duration<<"\n";
	} while(key != 27);
        
	cv::waitKey(0);
	return 0;
}

